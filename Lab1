import random
import types

def sum(weights, values):
    sum = 0
    for i in range(0, len(weights)):
        sum += weights[i] * values[i]
    return sum

def randomizeInputs(x, y, i):
    results = []
    for i in range(0, i):
        nextY = y + random.random() * 0.15
        nextX = x + random.random() * 0.15
        results.append((nextX, nextY))
    return results

def trainPercepton(trainingSet, activation, biasInfo):
    eras = 0
    alpha = 0.00001
    bias = [biasInfo.bias]
    weights = [random.random() * 0.05 for _ in bias + trainingSet[0][0]]
    cont = True
    while cont:
        eras += 1
        cont = False
        for (values, category) in trainingSet: 
            values = bias + values
            stimulation = sum(weights, values)
            result = activation.max if stimulation > biasInfo.theta else activation.min
            error = category - result
            if error != 0:
                cont = True
            for i in range(0, len(values)):
                weights[i] = weights[i] + alpha * error * values[i]
    
    return weights, eras

def test(testingSet, weights, activation, biasInfo):
    errors = []
    for (values, category) in testingSet: 
        values = [biasInfo.bias] + values
        stimulation = sum(weights, values)
        result = activation.max if stimulation > biasInfo.theta else activation.min
        if result != category:
            errors.append(values)
    return errors


def doTest(firstClass, secondClass, activation, biasInfo):
    trainingSet = firstClass[int(len(firstClass) / 2):] + secondClass[int(len(secondClass) / 2):]
    random.shuffle(trainingSet)
    testingSet = firstClass[:int(len(firstClass) / 2)] + secondClass[:int(len(secondClass) / 2)]

    weights, eras = trainPercepton(trainingSet, activation, biasInfo)
    print(str(test(testingSet, weights, activation, biasInfo)) + " " + str(eras))

def getInputs():
    shouldGet = input('Wykorzystac predefiniowane wartosci?')
    if shouldGet == "tak":
        return  [([0,0], 0), ([1,0], 0), ([0,1], 0), ([1,1], 1)]
    print('Wpisz koordynat X, Y i klasę(1 lub 0) oddzieloną spacjami')
    inputs = []
    while True:
        values = input().split(' ')
        input.append(([int(values[0]), int(values[1])], int(values[2])))
        if input('kontynuowac?') == 'nie':
            break
    return inputs

if __name__ == '__main__':
    dataSet = getInputs()
    class1 = list(filter(lambda x: x[1] == 1, dataSet))
    class0 = list(filter(lambda x: x[1] == 0, dataSet))
    relation = len(class1) / len(class0)
    
    numOfClass1 = 10 / relation if relation < 0 else 10 
    numOfClass0 = 10 * relation if relation > 0 else 10 

    generatedClass1 = [([genX, genY], 1) 
        for ([x,y], _) in class1 
        for (genX, genY) in randomizeInputs(x, y, 10 * int(numOfClass1))]
    generatedClass0 = [([genX, genY], 0) 
        for ([x,y], _) in class0 
        for (genX, genY) in randomizeInputs(x, y, 10 * int(numOfClass0))]
    generatedClassMinus1 = [([x, y], -1) for ([x, y], _) in generatedClass0]
    
    activation0 = types.SimpleNamespace(max=1, min = 0)
    activationMinus =  types.SimpleNamespace(max=1, min = -1)

    noBias = types.SimpleNamespace(bias=0, theta=0.65)
    bias = types.SimpleNamespace(bias=1, theta=0)
    
    doTest(generatedClass1, generatedClass0, activation0, noBias)
    doTest(generatedClass1, generatedClassMinus1, activationMinus, noBias)
    
    doTest(generatedClass1, generatedClass0, activation0, bias)
    doTest(generatedClass1, generatedClassMinus1, activationMinus, bias)





            
